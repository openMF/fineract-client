package org.openapitools.client.infrastructure

import com.google.gson.Gson
import com.google.gson.JsonParseException
import com.google.gson.TypeAdapter
import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonToken
import com.google.gson.stream.JsonWriter
import io.gsonfire.GsonFireBuilder
import okhttp3.RequestBody
import okhttp3.ResponseBody
import retrofit2.Converter
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.io.IOException
import java.lang.reflect.Type
import java.text.SimpleDateFormat
import java.util.Date

// This class was originally generated by OpenAPI Generator (https://openapi-generator.tech),
// but then had to be manually edited by Michael Vorburger.ch to fix https://issues.apache.org/jira/browse/FINERACT-1220.
// It is intentionally NOT public, as it's considered an "implementation detail".
// The original JSON class is deleted during the build (see FINERACT-1231).
internal class JSON {
    val gson: Gson

    init {
        val dateTypeAdapter = DateTypeAdapter()
        gson = GsonFireBuilder().createGsonBuilder()
            .registerTypeAdapter(Date::class.java, dateTypeAdapter)
            .create()
    }

    /**
     * GSON TypeAdapter for JSR-310 LocalDate type, which Fineract API's RETURNS as JSON array in the
     * <tt>[2009,1,1]</tt> format, but EXPECTS as String not Array and with a locale and dateFormat. Weird, but so it is
     * (see FINERACT-1220 & FINERACT-1233).
     */
    class DateTypeAdapter : TypeAdapter<Date?>() {
        // NB this format is referenced from org.apache.fineract.client.util.FineractClient.DATE_FORMAT
        private val formatter = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")

        @Throws(IOException::class)
        override fun write(out: JsonWriter, date: Date?) {
            if (date == null) {
                out.nullValue()
            } else {
                out.value(formatter.format(date))
            }
        }

        @Throws(IOException::class)
        override fun read(`in`: JsonReader): Date? {
            when (`in`.peek()) {
                JsonToken.NULL -> {
                    `in`.nextNull()
                    return null
                }

                JsonToken.BEGIN_ARRAY -> {
                    `in`.beginArray()
                    val year = `in`.nextInt()
                    val month = `in`.nextInt()
                    val day = `in`.nextInt()
                    `in`.endArray()
                    return Date(year, month, day)
                }

                else -> throw JsonParseException(
                    "Fineract's API normally always sends LocalDate as e.g. [2009,1,1].. or does it not?! (FINERACT-1220)"
                )
            }
        }
    }

    // The following is not from the generated JSON class, but from the original generated ApiClient.
    // The original class ApiClass, just like the JSON class, is deleted during the build (see FINERACT-1231).
    /**
     * This wrapper is to take care of this case: when the deserialization fails due to JsonParseException and the
     * expected type is String, then just return the body string.
     */
    class GsonResponseBodyConverterToString<T> internal constructor(
        private val gson: Gson,
        private val type: Type
    ) :
        Converter<ResponseBody, T> {
        @Throws(IOException::class)
        override fun convert(value: ResponseBody): T {
            val returned = value.string()
            return try {
                gson.fromJson(returned, type)
            } catch (e: JsonParseException) {
                returned as T
            }
        }
    }

    class GsonCustomConverterFactory private constructor(gson: Gson?) : Converter.Factory() {
        private val gson: Gson
        private val gsonConverterFactory: GsonConverterFactory

        init {
            if (gson == null) {
                throw NullPointerException("gson == null")
            }
            this.gson = gson
            this.gsonConverterFactory = GsonConverterFactory.create(gson)
        }

        override fun responseBodyConverter(
            type: Type,
            annotations: Array<Annotation>,
            retrofit: Retrofit
        ): Converter<ResponseBody, *>? {
            if (type == String::class.java) {
                return GsonResponseBodyConverterToString<Any>(gson, type)
            }
            return gsonConverterFactory.responseBodyConverter(type, annotations, retrofit)
        }

        override fun requestBodyConverter(
            type: Type,
            parameterAnnotations: Array<Annotation>,
            methodAnnotations: Array<Annotation>,
            retrofit: Retrofit
        ): Converter<*, RequestBody>? {
            return gsonConverterFactory.requestBodyConverter(
                type,
                parameterAnnotations,
                methodAnnotations,
                retrofit
            )
        }

        companion object {
            fun create(gson: Gson?): GsonCustomConverterFactory {
                return GsonCustomConverterFactory(gson)
            }
        }
    }
}